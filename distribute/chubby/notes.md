# Chubby lock service

chubby的目的就是为一些低耦合的分布式系统提供粗粒度的锁服务，以及可靠（但是低容量）的存储。

chubby提供的接口则类似于一个带有锁的分布式文件系统。但是chubby的设计重点在于可用性以及可靠性。而非高性能。

# Introduction

lock service的目的是让客户去同步他们的活动，并且对一些信息达成一致。

我们希望chubby为一些系统提供粗粒度的锁服务，特别的是处理选主的问题。比如GFS通过chubby来指定一个master。bigtable也通过chubby选主，并且允许master

chubby的也用于存储一些小数据量的meta-data。他通常被用作一些分布式系统的根数据结构。比如bigtable的root table

chubby的核心不是提出创新点，而是engineering。论文主要在说他们的决策以及理由

# Design

## Rationale

google实现了一个paxos库，但是为什么要选择锁服务而不是直接用paxos来做共识呢？

某些情况下，开发者最开始去prototype一个东西的时候，他们的负载比较小。并且不需要高可用性。并且代码没有经过去为了共识协议调整他们的结构。当服务成熟的时候，这时候可用性比较重要了，他们需要进行为现有的系统加上replication以及选主。虽然这个目的可以通过共识协议库来解决，一个lock server可以让我们可以更加容易的维持现有代码的结构。

比如我们要去选择一个master。我们可以通过添加简单的语句来实现这个操作。首先一个server会尝试获得锁，从而变成master，并且传递一个额外的整数（lock acquisition count），以及一个if语句用来判断acquisition count是不是比当前值小，从而防止延迟的包影响当前的服务。

相当于是一定程度上解偶了consensus模块和逻辑模块。

第二点是通过name service来提供给用户读写文件的接口。但是他这块理由我有点看不懂...

第三点是程序员更熟悉基于锁的接口。因为大多数人都遇到过锁。

最后，如果我们直接使用consensus服务的话，需要副本来达成高可用性。比如一个用户系统用的是lock service，他们只需要一个副本就可以获得锁。但是如果用共识库的话则需要多个副本。举个例子就是比如我们有100个客户端，如果在这里面嵌入共识我们就要有100个对等点参与共识，并对维护的状态进行复制。而使用lock service的话，则数量与客户端的数量无关。从而减少了副本的数量。

所以感觉核心点还是解偶，把共识模块独立出来处理元信息。然后用锁服务来提供接口，并且提供读写元信息的能力。

客户期待知道什么时候主副本变化了，所以我们需要实现一种通知机制来防止用户不断的轮询。但是用户仍然可能需要不断的去访问chubby中的数据，并且chubby中的数据变化的很少。所以我们提供了对文件的缓存。（我猜测应该是去监视这个文件，然后当文件内容变化的时候去通知用户，从而保证缓存的一致性）

chubby使用coarse-grained lock。从而减少lock server的负载。同时可以减少lock server failure对于lock的影响。相对来说，细粒度的锁就更容易受到lock server failure的影响。

通过locking service，客户负责提供支持他们负载的服务器，而不是lock service，同时也从实现共识协议的复杂性中解脱出来。